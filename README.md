# MY-LC-NOTE
This reposity is used to recoed my LeetCode practice code(including C++ and other programing languages), as well as my thinking processes and study notes. There may alse be some addtional content included. 

## 代码随想录
| 题单 | 已完成 | 未完成 | 总计 |
| :-----| ----: | :----: | :----: |
| 代码随想录-数组 | 1-7 | 1 | 8|
| 代码随想录-链表 | 1-8 | 0 | 8 |
| 代码随想录-哈希表 | 1-9 | 9 | 9 |
| 代码随想录-字符串 | 2 | 7 | 7 |
| 代码随想录-双指针法 | 0 | 10 | 10 |
| 代码随想录-栈与队列 | 0 | 8 | 8 |
| 代码随想录-二叉树 | 0 | 33 | 33 |
| 代码随想录-回溯算法 | 0 | 21 | 21 |
| 代码随想录-贪心算法 | 0 | 23 | 23 |
| 代码随想录-动态规划 | 0 | 53 | 53 |
| 代码随想录-单调栈 | 0 | 5 | 5 |
| 代码随想录-图论 | 0 | 30 | 30 |

## 数据结构实现

### 单链表
C++实现：实现构造函数的好处在于，可以在初始化的时候赋值，比如ListNode* head = new ListNode(5);
```C++
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```
## 15_3sum

**好难的题！！！给我整不会了！！！！！！**

首先，这道题需要对数组进行一个排序（我发现排序真是个好东西）。这个是为了去除重复的数组。
按照一般情况，直接进行枚举的话，一共是n*(n-1)*(n-2)种情况，这会导致个什么？假设有a+b+c = 0 满足条件，
直接这么枚举还会有b+a+c = 0和c+b+a = 0一共六种情况，大大的重复了。如果改进一下枚举，采用下述的枚举可以吗？
```C++
for(int i = 0;i<n;i++){
    for(int j = i+1;j<n;j++){
        for(int k = j+1;k<n;k++){
            if(nums[i]+nums[j]+nums[k] == 0){
                result.push_back({nums[i],nums[j],nums[k]});
            }
        }
    }
}
```
答案是依旧不可以。为什么？因为这样只消除了枚举顺序带来的重复（下标ijk和下标jik不会重复）。数值上的重复依旧是不可避免地。
也就是说，如果三个数a+b+c = 0，还能找到下标不一样的数也满足a+b+c = 0。如[-1,0,1,2,-1,-4]就有{0,1,2}和{1，2，4}。
所以说我们要排序，将数组按小到大先排序了，再在枚举的时候跳过相等的数字。这样可以确保枚举的时候一定是$a<=b<=c$的。

这样子就避免了下标带来的重复，和数值上的重复，因为输出的三元组是递增的，满足这个顺序的三元组有且仅有一个。也就是排除了{-1,0,1}的重复解{0,1，-1}


然后他用了一个双指针，就是说，在second递增的时候，指针third递减。因为三数之和为0，second对应的数值变大了，third对应的数值一定就要变小。

直到second和third相遇了，都没找到就结束。
这样子时间复杂度只有O(n^2)。还有就是，因为会出现相邻元素相同的问题，为了避免所以对于重复元素一律跳过，即nums[ptr] == nums[ptr-1]时ptr跳过。

## 18_4sum
刚开始做没想到怎么做，直接用的一层哈希表企图降低复杂度到O(N^3)，但是事实证明这个题他就不该用哈希表
他和三数之和是一样的做法，只多了一点点特性——剪枝
妙就妙在用了两种剪枝：
1. 确定第一个数之后，如果`(long)nums[first]+nums[first+1]+nums[first+2]+nums[first+3] > (long)target`那么说明此题无解，直接break;
2. 确定第一个数之后，如果`(long)nums[first]+nums[n-1]+nums[n-2]+nums[n-3] < (long)target`那么说明这个数这一轮无解了，直接continue;

但是官方题解只在外面两层循环做了剪枝，大概是觉得里面两层复杂度（虽然两层但是复杂度O(N)）不需要剪枝吧，所以三数之和为什么不剪枝。

还有一个就是，四数之和竟然越界了然后要改用long类型去操作。

## 19_remove_nth_node_from_end_of_list.cpp
我的做法是：创建一个dummy node（就不需要对头节点进行特殊的判断了），先遍历一遍list，记录长度的同时，把node ptr存在容器里。后续只需要对容器的第length - n个结点后的进行删除即可。
时间复杂度和空间复杂度都是O(L)
还有个很妙的做法，遍历的过程中将node入栈，完事后第n个出栈的node就是要删除的节点，此时的栈顶node就是它的前驱节点，就可以删除了
还有个最妙的做法，双指针，first比second超前n个节点，这样first到末尾的时候，second刚刚好就是倒数第n个，如此一来就解决了

## 59_generate_spiral_matrix.cpp
注意get_direction要首尾相连，检查的时候可以注意 一下，rdlur循环。然后没了，没什么需要注意的

## 124_linked_list_cycle_ii
方法一：哈希表，常规思路，空间复杂度O(N)

方法二：快慢指针，这到底谁想出来的，空间复杂度O(1)
推导如下，刚开始fast和slow指向head，然后fast以两倍slow的速度前进，slow一次前进一步。可想而知，fast会先进环（如果有的话），然后再环里面跑直到slow也进来最后二者相遇。
无图，图看官方题解去。
设，slow进入环内跑了b距离后和fast相遇（这个b一定小于等于环的长度，因为即使在最极端的情况下，也就是slow进来的时候fast刚好从入口离开的情况下，fast也只需两圈就可以追上），c是环的长度l - b
那么有，fast在环内走了n圈和b相遇：
$$ a + b + n(b + c) = 2(a+b) \\
a+ b + nb+nc = 2a+2b \\
a = (n-1)b + nc = c + (n - 1)(b+c)
$$
也就是说，a的距离刚好就等于，环剩下的距离加上n-1圈的环。那么在俩个指针相遇的时刻，设计一个指针ptr从head开始走，当ptr和slow相遇的时候，slow刚好走了c+(n-1)圈和ptr相遇，ptr走过的路程就是就是head到入环点的路程

## 160_intersection_of_two_linked_list_node
方法一，哈希表建表A，轮到B遍历的时候查询一下B中的节点是否在A中出现，出现就返回。时间复杂度O(m+n)，空间复杂度O(m)。
**方法二，双指针**，这是个很妙的方法。首先，记录下pA和pB，如果他们俩有一个为空就返回nullptr。下面分类讨论，假设AB有相交，长度分别为m、n，公共部分长度为c。令指针pA和pB遍历A和B，当pA遍历完A就跳转到B的head继续遍历，当pB遍历完B就跳转到A的head继续遍历，两个指针最后走的长度是一样的，都是m+n -c（a+c +b = b + c +a），最后一定会汇聚到那个相交节点。如果两个相等且不为空，即为相交节点。

## 202_happy_number
快乐数（lc easy?????）
在做题之前首先要回答一个问题——就是一个数的各位置数字平方和是个什么数？
简单画个表格看看每个数的next是什么情况：
| 位数 | 最大数 | next | 
| :-----| ----: | :----: | 
| 1 | 9 | 81 |
| 2 | 99 | 162 |
| 3 | 999 | 243 |
| 4 | 9999 | 324 |
| ... | ... | ... |
| 10 | 9999999999 | 810 |

不难看出，3位数的数next最大不超过243，这说明了什么呢？也就是说，只要是个三位数，next一定是个三位数而且是小于243的，对于其他位数的情况以此类推即可。

所以对一个数循环提取各位置数平方加和的结果，一直做下去，有三种可能：
1. 7-49-97-130-10-1 收敛到1，也就是快乐数
2. 在某个地方开始产生环，无法收敛到1，不是快乐数
3. 一直变大变大直到正无穷？错！

事实证明这是不可能的，因为根据next的性质可知，平方和之后它是会不断缩小的，所以不会出现这种情况。那么问题就简单多了，我们只需判断这个数它一直做下去是第一还是第二种情况即可，第二种情况用快慢指针即可检测（具体请看lc124判断链表的环）。



## 206_reverse_linked_lists.cpp
我采用的做法是迭代，用变量存储上一个和下一个节点，然后交换就可以了；
**比较需要注意的地方大概是，我采用了currNode为空时跳出循环，这本身没任何问题，问题出在我选择了返回currNode作为结果。你知道问题出在哪里了吗？——对的，跳出循环的时候curr已经是空的了，这么返回的一定是空指针，所以应该返回curr的上一个结果pre**

## 242_valid_anagram
方法一、排序后，依次比较元素是否相同，没什么特别的，时间复杂度是排序的复杂度

方法二、哈希表，与题解不同的是我用了库，他没有，他直接用了一个26的整数数组充当哈希表，还要注意char - 'a'才能访问数组下标，其他没什么特别的。

## 383_ransom_note
这道题没什么好注意的，主要是提一个点，就是如果hashTable[a]++对一个没出现过的元素a进行自增，那么是把value初始化为0后进行自增。相应的后续对这个键的值进行--，这个键也不会消失，所以用count判断会出问题，虽然值是0意味着某种程度上它已经不可用了但键还是在的。
## 707_design_linked_list.cpp
这道题需要注意的是单链表的数据结构：
1. 在最开头有一个哨兵节点作为头节点。
`sentinel -> 下标0 -> 下标1 -> ... -> 下标n-1 -> nullptr` 
2. 需要有一个数n来保存当前的节点个数，方便做越界判断等。
3. 在做题的时候只需要实现一个addAtIndex函数，也就是在下标index前插入的函数，然后就可以通过该函数在head和tail进行插入。